!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
LISTENQ	main.cpp	2;"	d	file:
SERV_PORT	main.cpp	1;"	d	file:
accepted	reply.h	/^		accepted = 202,$/;"	e	enum:reply::status_type
bad_gateway	reply.h	/^		bad_gateway = 502,$/;"	e	enum:reply::status_type
bad_request	reply.h	/^		bad_request = 400,$/;"	e	enum:reply::status_type
content	reply.h	/^	string content;$/;"	m	class:reply
created	reply.h	/^		created = 201,$/;"	e	enum:reply::status_type
forbidden	reply.h	/^		forbidden = 403,$/;"	e	enum:reply::status_type
getreq	request_parser.cpp	/^request request_parser::getreq()$/;"	f	class:request_parser
getreq	request_parser.h	/^	request getreq();$/;"	p	class:request_parser
header	request.h	/^struct header$/;"	s
headers	reply.h	/^	vector<header> headers;$/;"	m	class:reply
headers	request.h	/^	vector<header> headers;$/;"	m	struct:request
internal_server_error	reply.h	/^		internal_server_error = 500,$/;"	e	enum:reply::status_type
m_docroot	request_handler.h	/^	string m_docroot;$/;"	m	class:request_handler
main	main.cpp	/^int main()$/;"	f
main	reply.cpp	/^int main()$/;"	f
method	request.h	/^	string method;$/;"	m	struct:request
moved_permanently	reply.h	/^		moved_permanently = 301,$/;"	e	enum:reply::status_type
moved_temporarily	reply.h	/^		moved_temporarily = 302,$/;"	e	enum:reply::status_type
name	request.h	/^	string name;$/;"	m	struct:header
no_content	reply.h	/^		no_content = 204,$/;"	e	enum:reply::status_type
not_found	reply.h	/^		not_found = 404,$/;"	e	enum:reply::status_type
not_implemented	reply.h	/^		not_implemented = 501,$/;"	e	enum:reply::status_type
not_modified	reply.h	/^		not_modified = 304,$/;"	e	enum:reply::status_type
ok	reply.h	/^		ok = 200,$/;"	e	enum:reply::status_type
parse	request_parser.cpp	/^bool request_parser::parse(string packet)$/;"	f	class:request_parser
parse	request_parser.h	/^	bool parse(string);$/;"	p	class:request_parser
parse_reqheader	request_parser.cpp	/^bool request_parser::parse_reqheader(string header)$/;"	f	class:request_parser
parse_reqheader	request_parser.h	/^	bool parse_reqheader(string);$/;"	p	class:request_parser
parse_reqline	request_parser.cpp	/^bool request_parser::parse_reqline(string statu_line)$/;"	f	class:request_parser
parse_reqline	request_parser.h	/^	bool parse_reqline(string);$/;"	p	class:request_parser
produre_reply	request_handler.cpp	/^void request_handler::produre_reply(const request& req, reply& rep)$/;"	f	class:request_handler
produre_reply	request_handler.h	/^	void produre_reply(const request& req, reply& rep);$/;"	p	class:request_handler
reply	reply.h	/^class reply$/;"	c
req	request_parser.h	/^	request req;$/;"	m	class:request_parser
request	request.h	/^struct request$/;"	s
request_handler	request_handler.cpp	/^request_handler::request_handler(const string& docroot):m_docroot(docroot)$/;"	f	class:request_handler
request_handler	request_handler.h	/^	explicit request_handler(const string& docroot);$/;"	p	class:request_handler
request_handler	request_handler.h	/^class request_handler$/;"	c
request_parser	request_parser.h	/^class request_parser$/;"	c
reset	reply.h	/^	void reset();$/;"	p	class:reply
reset	request_parser.cpp	/^void request_parser::reset()$/;"	f	class:request_parser
reset	request_parser.h	/^	void reset();$/;"	p	class:request_parser
service_unavailable	reply.h	/^		service_unavailable = 503$/;"	e	enum:reply::status_type
set_content	reply.cpp	/^void reply::set_content(const string content)$/;"	f	class:reply
set_content	reply.h	/^	void set_content(const string );$/;"	p	class:reply
set_headers	reply.cpp	/^void reply::set_headers(const vector<header> headers)$/;"	f	class:reply
set_headers	reply.h	/^	void set_headers(const vector<header> );$/;"	p	class:reply
set_status	reply.cpp	/^void reply::set_status(const status_type status)$/;"	f	class:reply
set_status	reply.h	/^	void set_status(const status_type);$/;"	p	class:reply
status	reply.h	/^	}status;$/;"	m	class:reply	typeref:enum:reply::status_type
status_to_string	reply.cpp	/^string reply::status_to_string()$/;"	f	class:reply
status_to_string	reply.h	/^	string status_to_string();$/;"	p	class:reply
status_type	reply.h	/^	enum status_type$/;"	g	class:reply
to_buffers	reply.cpp	/^string reply::to_buffers()$/;"	f	class:reply
to_buffers	reply.h	/^	string to_buffers();$/;"	p	class:reply
to_reply_content	reply.cpp	/^void reply::to_reply_content()$/;"	f	class:reply
to_reply_content	reply.h	/^	void to_reply_content();$/;"	p	class:reply
to_reply_headers	reply.cpp	/^void reply::to_reply_headers()$/;"	f	class:reply
to_reply_headers	reply.h	/^	void to_reply_headers();$/;"	p	class:reply
unauthorized	reply.h	/^		unauthorized = 401,$/;"	e	enum:reply::status_type
url	request.h	/^	string url;$/;"	m	struct:request
url_decode	request_handler.cpp	/^bool request_handler::url_decode(const string& in, string& out)$/;"	f	class:request_handler
url_decode	request_handler.h	/^	static bool url_decode(const string& in, string& out);$/;"	p	class:request_handler
value	request.h	/^	string value;$/;"	m	struct:header
version	request.h	/^	string version;$/;"	m	struct:request
